* 生成器、迭代器、装饰器区别？解释下
* yeild 是什么，和return 什么区别
### 进程、线程、协程联系区别？
>进程是资源分配的单位

>线程是操作系统调度的单位

>进程切换需要的资源很最大，效率很低

>线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）

>协程切换任务资源很小，效率高

>多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发`
1. 迭代器iterator：记住遍历的位置 的对象
* 可迭代对象：list、tuple、str

        from collections import Iterable
        isinstance([],Iterable)
        isinstance({},Iterable)
        isinstance("abc",Iterable)
2. 可迭代对象的本质：可迭代对象通过__iter__方法向我们提供一个迭代器
     通过这个迭代器来依次获取对象中的每一个数据
3. Python3中是对象的__next__方法，Python2中是对象的next()方法
4. 迭代器自身正是一个迭代器，
 
        the_iter = iter(可迭代对象)
        next(the_iter)
        #...
        #迭代完后再用next()函数
        #会抛出StopIteration的异常
5. 总结
* for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，
* 然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，
* 当遇到StopIteration的异常后循环结束。
### 协程 （微线程、纤程）Coroutine
协程：如果一个线程等待某些条件，可以充分利用这个时间去做其它事情，其实这就是：协程方式


### python27中
* range(存取生成的值) 
* xrange（迭代器，存取生成方式，占用极小空间），都可以用作for循环
> 迭代器最核心的功能就是可以通过next()函数的调用来返回下一个数据值。
如果每次返回的数据值不是在一个已有的数据集合中读取的，
而是通过程序按照一定的规律计算生成的，
那么也就意味着可以不用再依赖一个已有的数据集合，
也就是说不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，
这样可以节省大量的存储（内存）空间。

### 生成器generator
> 迭代器，关于当前迭代到的状态需要我们自己记录，
进而才能根据当前状态生成下一个数据。
为了达到记录当前状态，并配合next()函数进行迭代使用
* 生成器是一类特殊的迭代器
* yield关键字有两点作用：
1. 保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起
2. 将yield关键字后面表达式的值作为返回值返回，此时可以理解为起到了return的作用
* 使用send唤醒：唤醒的同时向断点处传入一个附加数据
* c.__next__()方法,next(c)函数等价c.send(None)，


### 协程：
>在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，
然后切换到另外一个函数中执行

>协程的切换只是单纯的操作CPU的上下文

>每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作
线程切换从系统层面远不止保存和恢复 CPU上下文这么简单

        from gevent import monkey
        monkey.patch_all()
        # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块