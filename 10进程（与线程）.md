* 程序是静态的，
* 程序运行起来后，进程=代码+用到的资源
* 操作系统分配资源的基本单元
* 进程间不同享全局变量,multiprocessing模块的Queue实现多进程之间的数据传递

        from multiprossessing import Queue
        q = Queue(3) # 初始化一个Queue对象，最多可接收三条put消息;缺省或负值无上限
        q.put("消息1")
        try:
            q.put("消息4",True,2)
        except:
            print("消息列队已满，现有消息数量:%s"%q.qsize())
        if not q.full():
            q.put_nowait("消息4")
        if not q.empty():
        for i in range(q.qsize()):
            print(q.get_nowait())
    
* 进程的状态：
    1. 任务数往往大于cpu的核数，
    2. 即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，
    3. 因此导致了有了不同的状态
    4.
       1. 启动：新建-》就绪
       2. 调度：就绪—》运行
       3. 等待条件：运行-》堵塞(等待)
       4. 满足条件：堵塞-》就绪
       5. 结束：运行-》死亡
    5. 就绪态：运行的条件都已经满足，正在等在cpu执行
    6. 执行态：cpu正在执行其功能
    7. 等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态
* 写时拷贝    

* 操作系统的调度算法：优先等级法，时间片轮法

##进程与线程的区别
1.
    1. 进程是系统进行资源分配和调度的一个独立单位.
    2. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位
    3. 线程自己基本上不拥有系统资源,有运行中必不可少的资源(如程序计数器,一组寄存器和栈)
    4. 线程与同属一个进程的其他的线程共享进程所拥有的全部资源.
2. 一个程序至少有一个进程,一个进程至少有一个线程;
3. 线程不能够独立执行，必须依存在进程中
3. 线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。
4. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 
5. 进程->流水线，线程->流水线上的工人 
6. 线程执行开销小，但不利于资源的管理和保护；而进程正相反。

## 进程间的通信-Queue
* (socket也是进程间通信的一种方式)
* 文件

3. Process语法结构如下：
Process([group [, target [, name [, args [, kwargs]]]]])

target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码

args：给target指定的函数传递的参数，以元组的方式传递

`kwargs：给target指定的函数传递命名参数`，以字典方式传递

run_demo(name, age, **kwargs):

name：给进程设定一个名字，可以不设定

group：指定进程组，大多数情况下用不到

4. Process创建的实例对象的常用方法：
start()：启动子进程实例（创建子进程）

is_alive()：判断进程子进程是否还在活着

`join([timeout])：是否等待子进程执行结束，或等待多少秒`..等待他结束在进行下一步

terminate()：不管任务是否完成，立即终止子进程

5.Process创建的实例对象的常用属性：
name：当前进程的别名，默认为`Process-N`，N为从1开始递增的整数

pid：当前进程的pid（进程号）
    
    
6. os.getpid()



# 队列
* Queue.get([block[, timeout]])：

获取队列中的一条消息，然后将其从列队中移除，block默认值为True；
1. 如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出"Queue.Empty"异常；
2. 如果block值为False，消息列队如果为空，则会立刻抛出"Queue.Empty"异常；
3. Queue.get_nowait()：相当Queue.get(False)；
* Queue.put(item,[block[, timeout]])：

将item消息写入队列，block默认值为True；
1. 如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出"Queue.Full"异常；
2. 如果block值为False，消息列队如果没有空间可写入，则会立刻抛出"Queue.Full"异常；
3. Queue.put_nowait(item)：相当Queue.put(item, False)；


## 进程池
* 初始化Pool时，可以指定一个最大进程数
* 当有新的请求提交到Pool中：
    1. 池还没有满，那么就会创建一个新的进程执行该请求
    2. 进程数达到最大，该请求就会等待，直到池中有进程结束用之前的进程来执行新的任务
   
   
### multiprocessing.Pool常用函数解析：

* apply_async(func[, args[, kwds]]) ：
    1. 使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程）
    2. args为传递给func的参数列表，kwds为传递给func的关键字参数列表；
* close()：
    关闭Pool，使其不再接受新的任务；
* terminate()：不管任务是否完成，立即终止；
* join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用
